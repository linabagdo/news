комментарии
1) после объявления функции описать её вывод: - вызывается с помощью help
def add(a, b):
    """
    Складывает 'a' и 'b', возвращая результат.
    
    Обратите внимание: функция работает с числовыми аргументами.
    :param a: первое слагаемое.
    :param b: второе слагаемое.
    :return: сумма 'a' и 'b'.
    
    >>> add(2, 3)
    5
    """
    return a + b

2) # такой комментарий через пробел после решетки (объясняет, для чего строка, если не понятно)
примеры:

1)
# Считаем количество необработанных заявок (включая отложенные)
pending_requests += 1
2)
port = 8080     # Не стандартный 80 порт из-за ограничений хостинга

так же можно писать две строки подряд, которые начинаются с #, но только до строки, например,

переменные и функции
маленькие буквы, слова разделяются нижним подчеркиванием

классы
все слова с большой буквы, без подчеркивания
экземпляры класса - как переменные
приватные переменные внутри класса - начинаются с нижнего подчеркивания

константы - заглавные буквы с нижним подчеркиванием

переопределение имен функций
можно переопределять имена, так как в этом случае объекты занимают столько же памяти, просто создается меньше переменных, а на имена переменных памяти тратится очень мало. Лучше переназывать, чтобы было понятно, что происходит. Если и так все понятно, можно не переназывать
для удобства можно создать функцию-помощника:

def parse_comma_separated_to_indexed_dict(text: str) -> dict[int, str]:
    """Преобразует строку 'a,b,c' в {0: 'a', 1: 'b', 2: 'c'}."""
    items = text.split(",")
    return dict(enumerate(items))

без необходимости не стоит оборачивать функции в классы, так как:
1.	экземпляр класса занимает лишнее место в памяти
2.	лишний уровень абстракции
3.	лишнее место в коде (класс просто вызывает функцию, которую можно было вызвать напрямую)

Но если внутри функции мы взаимодействуем с БД, лучше создать отдельный класс

импортировать модули по цепочке можно, но нельзя два модуля импортировать друг из друга, если это нужно сделать - создать третий файл, в который вынести "общее" необходимое 

при передаче разных параметров:
1) если два-три варианта: можно через if-else
2) если больше - словарь стратегий:
def clean_data(data):
    return [x.strip() for x in data]

def validate_data(data):
    return all(x for x in data)

def transform_data(data):
    return [x.upper() for x in data]

# Карта "режим → функция"
PROCESSORS = {
    "clean": clean_data,
    "validate": validate_data,
    "transform": transform_data,
}

